<!-- doc.py -->

Тернарный оператор - (усл) ? T : F
----------------------------------

*Тернарная условная операция* (лат. ternarius - "тройной") (обычно записывается как ?:) - во многих языках программирования операция,
возвращающая свой второй или третий операнд в зависимости от значения логического выражения, заданного первым операндом.

Массивы: одномерные, многомерные
--------------------------------

Условный оператор if else
-------------------------

Множественный выбор switch
--------------------------

Циклы с предусловием и постусловием: while, do while
----------------------------------------------------

Цикл for
--------

Записи (struct - структуры). typedef. Записи с вариантами (union)
-----------------------------------------------------------------

Операторы break, continue
-------------------------

Модули: заголовочный файл (header), основной файл (.c и .cpp, .h и .hpp)
------------------------------------------------------------------------


Домашнее задание
----------------
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.

Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1

Указатели, работа с памятью
===========================

Типы памяти: статическая, динамическая (куча), стек
---------------------------------------------------

Выделение и освобождение динамической памяти (malloc / free)
------------------------------------------------------------

Ссылки и указатели в C++: общее и различия
------------------------------------------

Операторы new и delete
----------------------

Утечки памяти и методы борьбы с ними
------------------------------------

Отличия C и C++ (ссылки, в приведении типов, перегрузка функций)
----------------------------------------------------------------

Использование динамической памяти на примере реализации структур данных: список, стек, очередь и "дерево"
---------------------------------------------------------------------------------------------------------


Решение квадратного уравнения - разбор домашнего задания
----------------------------------------------------------
Задание:
Написать программу, которое решает квадратное уравнение.
Пользователь вводит (с клавиатуры) три действительных
коэффициента a, b, c.
Программа выводит все решения уравнения (два, одно),
"решений нет", если их нет или "бесконечно много решений",
если подходит любое значение x (a = 0, b = 0, c = 0).
Обработать все варианты исходных данных.
a*x^2 + b*x + c = 0
#ifdef DEBUG
#else
#define SHOW(x)
#endif // DEBUG
``` cpp
// Точность сравнения с нулём
const double EPS = 1e-10;
```

Функция: решение квадратного уравнения
a,b,c - коэффициенты уравнения
результат функция выводит на экран
``` cpp
void solve_equation(double a, double b, double c) {
  if(fabs(a) < EPS) {
    if(fabs(b) < EPS) {
      if(fabs(c) < EPS) {
        // Если все три коэффициента нули, то x - любой
        // 0x^2 + 0x + 0 = 0
        cout << "x - any number" << endl;
        return;
      }

      // 0*x^2 + 0*x + не_ноль = 0 - решений нет
      cout << "no solutions" << endl;
      return;
    }

    // Линейное уравнение
    // 0*x^2 + b*x + c = 0
    double x = -c / b;
    cout << "x = " << x << endl;
    // Проверка решения
    cout << "0*x^2 + b*x + c = " << 0 * pow(x, 2) + b* x + c << endl;
    return;
  }

  // Вычисление дискриминанта
  double D = b * b - 4 * a * c;

  if((fabs(D) < EPS) && (D != 0)) {
    SHOW(a)
    SHOW(b)
    SHOW(c)
    cout << "FIND IT! :)" << endl;
    system("pause");
  }

  cout << "D = " << D << endl;

  if(fabs(D) == EPS) {
    double x = -b / (2 * a);
    cout << "x = " << x << endl;
    // Проверяем полученный x
    cout << "f(x) = " << a* x* x + b* x + c << endl;
    return;
  }

  if(D < 0) {
    cout << "no solutions" << endl;
    // Комплексные корни
    double x_re = -b / (2 * a);
    double x1_im = +sqrt(-D) / (2 * a);
    double x2_im = -sqrt(-D) / (2 * a);
    cout << "x1 = " << x_re << " + " << x1_im << " i" << endl;
    cout << "x2 = " << x_re << " + " << x2_im << " i" << endl;
    return;
  }

  // D > 0 - 2 действительных корня
  double x1 = (-b + sqrt(D)) / (2 * a);
  double x2 = (-b - sqrt(D)) / (2 * a);
  cout << "x1 = " << x1 << "  x2 = " << x2 << endl;
  // Проверяем полученные решения
  cout << "f(x1) = " << a* x1* x1 + b* x1 + c << endl;
  cout << "f(x2) = " << a* x2* x2 + b* x2 + c << endl;
}
```

Основная программа - тестирование
``` cpp
  while(1) {
    // Коэффициенты квадратного уравнения
    double a = 2, b, c;
    SHOW(a)
    cout << "a = ";
    cin >> a;

    if(!cin.good()) {
      SHOW(a)
      break;
    }

    cout << "b = ";
    cin >> b;
    cout << "c = ";
    cin >> c;
    cout << endl;

    // Вызов функции решения квадратного уравнения
    solve_equation(a, b, c);
```

[00_HW_done/main.cpp](00_HW_done/main.cpp)

Win1251 и в исходном тексте и в консоли
Ввод коэффициентов уравнения
Вычисление дискриминанта
Вычисление и вывод ответа(ов) x
[00_HomeWork/main.cpp](00_HomeWork/main.cpp)

Константы в if ставятся на первое место (до =)
``` cpp
const int a = 0;

int main() {
  int b = 0;

  if(a == b)
    cout << "a = b" << endl;
  else
    cout << "a != b" << endl;

  return 0;
}
```

[01_left_const/main.cpp](01_left_const/main.cpp)

В C++ перегрузка функций разрешена
С точки зрения С++ можно переопределять функции
(т.е. создавать несколько функций с одинаковым именем,
отличающиеся только типами аргументов).
В обычном С этого делать нельзя
Поэтому в C есть функции:
abs - модуль для целых чисел и
fabs - модуль для действительных чисел
[01_min_cpp/main.cpp](01_min_cpp/main.cpp)

Универсальная функция min на C
Макрос с использованием тернарного оператора
Нужен префикс f:  math.h -> abs/fabs
[01_min_ternary/main.c](01_min_ternary/main.c)

Тернарный оператор слева от присваивания
[01_ternary/main.cpp](01_ternary/main.cpp)

Подключение библиотек
Препроцессор
Preprocessor
#include <aclui.h>
Основная программа
#ifdef sizeof(int) != 2
#error This code only for Linux
#endif // WIN32
Вывод на экран строчки
int c = 1+2;
cin >> c;
a = 10;
c += a += 2;
SHOW(c);
Обмен двух переменных значениями
без третьей переменной
Код возврата
[02_preproc_Cpp/main.cpp](02_preproc_Cpp/main.cpp)

Тернарный оператор
Может находиться слева от оператора присваивания
Вложенные тернарные операторы
Если число делится на 5 и не делится на 7, то прибавить 2
иначе 4
[02_ternary/main.cpp](02_ternary/main.cpp)

Выводим N в двоичной системе счисления
разряды в обратном порядке
...
[02_while/main.cpp](02_while/main.cpp)

#include <stdio.h> // C
[03_for/main.cpp](03_for/main.cpp)

Множественный выбор switch
==========================
Вводим количество углов
``` cpp
  int N;
  cout << "Enter number of edges: ";
  cin >> N;
```

``` cpp
  switch(N) {
    case 1: // 1 угол => точка
      int i = 1, j = 10;

      for(int k = 0; k < 10; ++k) {

      }

      cout << "point" << endl; // Точка
      break;

    case 0: // 0 углов => пустота или круг
      cout << "emptiness / circle" << endl;
      break;

    case 2: // 2 угла => отрезок
      cout << "segment" << endl;
      break;

    case 3: // 3 угла => треугольник
      cout << "triangle" << endl;
      break;

    case 4: // 4 угла => четырёхугольник
    case 5:
      // Общая обработка для случаев N = 4,5
      cout << N << "th polygon" << endl;
      break;

    case -1:
      cout << "-1" << endl;

    case -2:
      cout << "-2" << endl;

    default:  // N < 0 => ошибка, N >= 5 углов => N-угольник
      cout << ((N < 0) ? "error" : "N-edged polygon") << endl;
      break;

    case -3:
      cout << "-3" << endl;
  }

```

[03_switch/main.cpp](03_switch/main.cpp)

int veryBigArray[SIZE];
[04_static_big_than_stack/main.cpp](04_static_big_than_stack/main.cpp)

x[0]
[04_visibility/main.cpp](04_visibility/main.cpp)

Итеративное вычисление факториала
Цикл от большего к меньшему
Итеративное вычисление факториала
Цикл от меньшего к большему
Рекурсивный способ вычисления факториала
Тестирование работы функции
cout << i << "! = " << res << endl;
[05_factorial/main.cpp](05_factorial/main.cpp)

Массивы
Одномерные
``` cpp
  int intArray[10];
  // int - тип элементов массива
  // intArray - название массива
  // 10 - количество элементов
  // Нумерация элементов: 0..9

  // Записываем 23 в первый элемент массива
  intArray[0] = 23;
  intArray[1] = 10; // Второй элемент массива

  cout << intArray[0] + intArray[1] << endl;

  // Увеличить каждый элемент массива на 10
  for(int i = 0; i < 10; ++i)
    intArray[i] += 10;

  // Поиск минимума в массиве
  int minValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] < minValue)
      minValue = intArray[i];

  // Поиск максимума в массиве
  int maxValue = intValue[0];

  for(int i = 1; i < 10; ++i)
    if(intArray[i] > maxValue)
      maxValue = intArray[i];

```

[07_arrays/main.cpp](07_arrays/main.cpp)

Пример массива для сортировки
Выводим массив
for(int i = 0; i < N; ++i)
cout << A[i] << " ";
cout << endl;
Задание: отсортировать массив
{-2, 10, 1, 5, 6, 11}
{-2, [ 1, 10, 5, 6, 11 ] }
{-2, 1, [5, 10, 6, 11 ] }
SWAP
int temp = A[i];
A[i] = A[i+1];
A[i+1] = temp;
A[i] ^= A[i+1] ^= A[i] ^= A[i+1];
-----
| 1 | 0
-----
| 3 | 1
-----
| 5 | 2
-----
| 6 | 3  <-- i
-----
| 7 | 4
-----
Снова вывести на экран
[08_array_sort/main.cpp](08_array_sort/main.cpp)

ЗАДАЧА: посчитать сумму.
Нумерация элементов массива с 0
Все элементы на чётных местах взять с "+"
Все элементы на нечётных местах с "-"
Чётные: 0, 2, 4, 6 и т.д.
Нечётные: 1, 3, 5...
Сумма равна 0
Если элемент нечётный i % 2 == 1
если чётный i % 2 == 0
result += (i % 2) ? -A[i] : A[i];
Суммируем только чётные
Суммируем только нечётные
1 - 3 -2 -4 + 2 -10 = -16
[08_array_task/main.cpp](08_array_task/main.cpp)

Минимум в массиве
-----------------
Пользователь вводит количество элементов
в массиве.
Затем каждый элемент массива.
Все элементы - целые (int).
Вызывается функция, возвращающая
минимальный элемент массива
Массив содержит хотя бы 1 элемент.
Задание: найти минимум и вернуть
``` cpp
int arrayMin(int A[], int N) { // var N
  assert(N > 0);
  int curMin = A[0]; // Текущий минимум - первый элемент

  for(int i = 1; i < N; ++i)
    if(A[i] < curMin) // Если встретили элемент меньше
      curMin = A[i];     // => обновили текущий минимум

  return curMin;
}

void f() { // procedure F;
}

int main() {
  assert( 2 * 2 == 4 );

  // Ввод количества элементов массива
  int N;

  do {
    if(!cin.good()) {
      cin.clear();
      cin.ignore(std::numeric_limits<std::streamsize>::max(),
                 '\n');
    }

    assert(cin.good());
    cout << "N = ";
    cin >> N;
  } while(!cin.good() && N < 1);

  // Заводим массив A в динамической памяти
  int* A = new int[N];

  // Вводим массив с консоли
  for(int i = 0; i < N; ++i) {
    cout << "A[" << i << "] = ";
    cin >> A[i];

    if(!cin.good()) {
      cin.clear();
      cin.ignore(std::numeric_limits<std::streamsize>::max(),
                 '\n');
      cout << "Error: not a valid integer" << endl;
      --i;
    }
  }

  // Вызываем функцию поиска минимума и
  // выводим результат на консоль
  cout << "min = " << arrayMin(A, N) << endl;

  // Очищаем занимаемую динамическую память
  delete[] A;

  return 0;
}
```

[09_array_task/main.cpp](09_array_task/main.cpp)

2D массив
статической памяти и сохраняют своё значение между вызовами
myArray[0] = 3
myArray[1] = 10
myArray[2] = 20
myArray[3] = 43
[09_arrays/main.cpp](09_arrays/main.cpp)

Поиск минимума
Сумма всех элементов
[09_arrays_2D/main.cpp](09_arrays_2D/main.cpp)

Вывод комплексного числа на экран
Comp res = {a.re + b.re, a.im + b.im};
[10_struct_C/main.c](10_struct_C/main.c)

Математические функции
typedef определение_типа название_типа;
typedef struct Point P;
Расстояние между двумя точками
[11_struct_C_Point2D/main.c](11_struct_C_Point2D/main.c)

Математические функции
typedef определение_типа название_типа;
typedef struct Point P;
Расстояние между двумя точками
[11_struct_cpp/main.cpp](11_struct_cpp/main.cpp)

Переполнение строки символов
Смертный Грех программиста №1 - источник уязвимостей
Ввод с клавиатуры
Ввод из файла
Получение пакета из сети
[13_strings_buffer_oveflow/main.cpp](13_strings_buffer_oveflow/main.cpp)

Стек
Добавить значение на вершину
TODO: реализовать
Забрать значение и вернуть
TODO: реализовать
[15_howework/main.cpp](15_howework/main.cpp)

``` cpp
const int SIZE = 100000;

// int A[]
// int &A[]
// /*, int arraySize*/ /* параметры */
int arrayMax(int* A) {
  // Предположим, что максимум это первый элемент
  int curMax = A[0];
  A[0] = -10; // Портим массив :)

  // Пробежим по остальным элементам массива
  // если какой-то элемент больше текущего
  // максимума, то запомним новый текущий максимум
  for(int i = 1; i < SIZE; ++i)
    if(A[i] > curMax)
      curMax = A[i];

  cout << "A[0] = " << A[0] << endl;

  return curMax;
}

int main() {
  // Массив в стеке
  int A[SIZE];

  // Заполняем случайными числами
  for(int i = 0; i < SIZE; ++i) {
    A[i] = rand() % 10000;    // от 0 до 9999
  }

  A[0] = -1;
  cout << "A[0] = " << A[0] << endl;

  cout << "max = " << arrayMax(A) << endl;

  cout << "A[0] = " << A[0] << endl;

  return 0;
}
```

[17_task_large_arrays/main.cpp](17_task_large_arrays/main.cpp)

cin >> p1.x >> p1.y;
cin.getline(str, 1024);
Вывести на экран точку 1
cin.clear();
[18_cin_cout/main.cpp](18_cin_cout/main.cpp)

Заводим в динамической памяти массив из 100 элементов
с типом int
Удалили
*(intPtr + 19*sizeof(int));
[19_memory/main.cpp](19_memory/main.cpp)

Структуры в чистом C
cout << "(" << p.x << ";" << p.y << ") ";
[C_struct/main.c](C_struct/main.c)

Сумма
TODO: Реализовать
Разность
TODO: Реализовать
Скалярное произведение векторов
TODO: Реализовать
Тестирование
[HomeWork_1/main.cpp](HomeWork_1/main.cpp)

Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N.
Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только
порядком слагаемых считаются одинаковыми.

Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
Макрос вычисления минимума в чистом C
``` cpp
#define MIN(x,y) (x < y) ? x : y

int min2(int x, int y) {
  return (x < y) ? x : y;
}

template <class T>
T min3(T x, T y) {
  return (x < y) ? x : y;
}
```

N - число для разложения
m - максимальное слагаемое в сумме
Цифры
Количество
Окончание рекурсии
x - текущее слагаемое
Сумма уменьшилась на x
Максимальное слагаемое - x
Убираем последнее слагаемое
Вводим число N
Вывод разложения на слагаемые
[HomeWork_2/main.cpp](HomeWork_2/main.cpp)

Домашнее задание - рекурсия
---------------------------
ЗАДАНИЕ:
Пользователь вводит натуральное число N. Нужно вывести все способы разложить его на слагаемые.
Способы отличающиеся только порядком слагаемых считаются одинаковыми.
-----------------------
Например N = 4:
4 = 4
4 = 3 + 1
4 = 2 + 2
4 = 2 + 1 + 1
4 = 1 + 1 + 1 + 1
Цифры
N - число для разложения
m - максимальное слагаемое в сумме
K - количество цифр
Окончание рекурсии
x - текущее слагаемое
Сумма уменьшилась на x
Максимальное слагаемое - x
Вводим число N
Цифры
new int[N]; - возвращает указатель на int
Вывод разложения на слагаемые
A = new type[SIZE]    delete[] A  -- создание и удаление массива
в динамической памяти
A = new type;  delete A; -- создание и удаление одиночного
объекта
[HomeWork_2_dynmemory/main.cpp](HomeWork_2_dynmemory/main.cpp)

Статическая память
int veryBigArray[SIZE];
int *a,b;
int *a; int b;
int *a,*b; - теперь оба указателя
a = (int *)12312;
[Memory/main.cpp](Memory/main.cpp)

SetConsoleOutputCP(65001);
SetConsoleCP(65001);
setlocale(LC_ALL, "Russian.UTF-8");
[RussianLocale/main.cpp](RussianLocale/main.cpp)

----------------------------------------
[Uravnenie/main.cpp](Uravnenie/main.cpp)

delete и delete[]
-----------------
Пусть у нас есть структура
``` cpp
struct Point {
  double x, y;
};
```

``` cpp
  // Заводим массив в динамической памяти
  int* intArray;
  intArray = new int[1000]; // new со скобками []
  intArray[0] = 10;
  intArray[1] = 23;
  delete[] intArray; // И delete должен быть со скобками

  Point* p = new Point;
  delete p; // delete без скобочек []
```

[cpp_dynamic/main.cpp](cpp_dynamic/main.cpp)

Без: using namespace std;
Win1251 и в исходном тексте и в консоли
[factorial/main.cpp](factorial/main.cpp)

Функции
...
using namespace my;
[function_declaration/main.cpp](function_declaration/main.cpp)

a^=b^=a^=b; // XOR - исключающее или
int g = f++ + f++ + f++;
g = f++;
cout << "a = " << a << " b = " << b << endl;
[lesson2_eq/main.cpp](lesson2_eq/main.cpp)

Память не отведена
Освобождаем динамическую память
чуть постарше 1
Два порядка байтов:
* Big-endian - старший байт в конце (IBM, майнфреймы, Sun Sparc и т.д.)
* Little-endian - младший байт первый (Intel и совместимые)
Little - основное преимущество - можно начинать складывать младшие байты
не дожидаясь пока старшие "прийдут" по шине
[malloc_free/main.c](malloc_free/main.c)

Поиск минимума в массиве
Пробежим по остальному массиву
каждый раз добавляя по одному элементу
и если он меньше текущего минимума
обновим минимум
Пробежим по остальному массиву
каждый раз добавляя по одному элементу
и если он меньше текущего минимума
обновим минимум
Индексы: 0  1  2  3
Вызов функции, ожидаем на выходе 4
[min_array/main.cpp](min_array/main.cpp)

Универсальный максимум в стиле "C"
[overload_c/main.c](overload_c/main.c)

Исходное значение не меняется
Передаём ссылку -> меняем исходное значение
Передаём указатель -> меняем исходное значение
[pointers/main.cpp](pointers/main.cpp)

Пример на ссылки и указатели
i - указатель, т.е. это
переменная содержащая адрес
i = &c;
[pointers/pointers2/main.cpp](pointers/pointers2/main.cpp)

Ссылки в C++
В с теперь будет адрес d
example1();
example3();
[references/main.cpp](references/main.cpp)

Элемент стека
``` cpp
struct StackElement {
  int value; // Значение элемента стека
  StackElement* next; // Указатель на следующий элемент стека
};
```

``` cpp
class Stack { // Можно использовать struct
  StackElement* root;
```

Конструктор:
------------
* называется так же как класс
* нет возвращаемого значения
* параметры как у обычных методов
* цель - инициализация объекта
``` cpp
  Stack() : root(NULL) { }
```

Деструктор
----------
Очистка памяти, освобождение ресурсов
``` cpp
  ~Stack() {
    while(root != NULL) {
      StackElement* saveForDelete = root;
      root = root->next;
      delete saveForDelete;
    }
  }
```

Поместить значение на вершину стека
``` cpp
  void push(int newValue) {
    // Создали новый элемент стека с новым значением
    StackElement* newElement = new StackElement;
    newElement->value = newValue;
    // "Подвешиваем" root к новому элементу
    newElement->next = root;
    // Делаем новый элемент первым в списке
    root = newElement;
  }
```

Получить значение с вершины стека
``` cpp
  int pop() {
    if(root == NULL) {
      cout << "Stack is empty!" << endl;
      return 0;
    }

    // Получаем верхний элемент
    StackElement* topElement = root;
    // Получаем значение верхнего элемента
    int value = topElement->value;
    // Переставим корень списка на след. элемент
    root = topElement->next;
    // Очистим память
    delete topElement;
    // Вернём значение
    return value;
  }
```

Показать все элементы
``` cpp
  void show() {
    for(StackElement* cur = root;
        cur != NULL;
        cur = cur->next)
      cout << cur->value << endl;
  }
```

Использование стека
``` cpp
  Stack s;
  s.push(2);
  s.push(4);
  s.push(5);
  s.show();
  cout << "pop result = " << s.pop() << endl;
  s.show();
```

Д.з. однонаправленный список
----------------------------
[stack/main.cpp](stack/main.cpp)

Win1251 и в исходном тексте и в консоли
system("chcp 65001");
freopen()
[switch/main.cpp](switch/main.cpp)


Домашнее задание - рекурсия
---------------------------
  ЗАДАНИЕ:
 Пользователь вводит натуральное число N.
 Нужно вывести все способы разложить его на слагаемые.
 Способы отличающиеся только
 порядком слагаемых считаются одинаковыми.

Например N = 4:
* 4 = 4
* 4 = 3 + 1
* 4 = 2 + 2
* 4 = 2 + 1 + 1
* 4 = 1 + 1 + 1 + 1

